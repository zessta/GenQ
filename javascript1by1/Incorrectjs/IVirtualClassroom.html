<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Virtual Classroom</title>
    <style>
        #video-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
        }
        video {
            width: 100%;
            border: 1px solid black;
        }
        #chat {
            border: 1px solid gray;
            height: 300px;
            overflow-y: scroll;
        }
        #chat input {
            width: 80%;
        }
    </style>
</head>
<body>
    <h1>Virtual Classroom</h1>
    <div id="video-grid"></div>
    <button id="share-screen">Share Screen</button>
    <button id="start-record">Start Recording</button>
    <button id="stop-record">Stop Recording</button>
    <div id="chat">
        <div id="messages"></div>
        <input id="message-input" type="text" placeholder="Type a message">
        <button id="send-message">Send</button>
    </div>
    <script>
        const videoGrid = document.getElementById('video-grid');
        const shareScreenButton = document.getElementById('share-screen');
        const startRecordButton = document.getElementById('start-record');
        const stopRecordButton = document.getElementById('stop-record');
        const messageInput = document.getElementById('message-input');
        const sendMessageButton = document.getElementById('send-message');
        const messages = document.getElementById('messages');

        let localStream;
        let screenStream;
        let mediaRecorder;
        let recordedChunks = [];

        async function startVideo() {
            localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            const videoElement = document.createElement('video');
            videoElement.srcObject = localStream;
            videoElement.play();
            videoGrid.appendChild(videoElement);
        }

        shareScreenButton.addEventListener('click', async () => {
            screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
            const screenVideoElement = document.createElement('video');
            screenVideoElement.srcObject = screenStream;
            screenVideoElement.play();
            videoGrid.appendChild(screenVideoElement);
        });

        startRecordButton.addEventListener('click', () => {
            mediaRecorder = new MediaRecorder(localStream);
            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };
            mediaRecorder.start();
        });

        stopRecordButton.addEventListener('click', () => {
            mediaRecorder.stop();
            const blob = new Blob(recordedChunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = 'recorded-class.webm';
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
        });

        sendMessageButton.addEventListener('click', () => {
            const message = messageInput.value;
            const messageElement = document.createElement('div');
            messageElement.innerText = message;
            messages.appendChild(messageElement);
            messageInput.value = '';
        });

        startVideo();
    </script>
</body>
</html>
```

### Intentional Mistakes:
1. **WebRTC Video Stream**: The `startVideo` function initializes the video stream but does not handle errors that might occur when accessing the user's media devices.
2. **Screen Sharing**: The shared screen stream does not include audio.
3. **Recording**: The `mediaRecorder` is only set to record the local stream, not the screen stream if it is shared. Also, the recorded chunks are not cleared after stopping the recording.
4. **Chat Feature**: The chat feature does not use WebSockets, so messages cannot be sent to other users in real-time.
5. **DOM Manipulation**: The video elements are not correctly removed from the DOM when the stream ends.

Candidates need to identify and fix these issues to ensure the application works as intended.
--------------------------------------------------------------------------------------------------------------

Here's a code snippet for an interactive map application with intentional mistakes. This application uses the Leaflet.js library for map rendering and manipulation. The code includes mistakes that test the interviewee's understanding of Map APIs, DOM manipulation, and event handling.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Interactive Map Application</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        #map { height: 600px; width: 100%; }
    </style>
</head>
<body>
    <h1>Interactive Map Application</h1>
    <div id="map"></div>
    <button id="addMarkerBtn">Add Marker</button>
    <button id="calculateRouteBtn">Calculate Route</button>
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script>
        // Initialize the map
        var map = L.map('map').setView([51.505, -0.09], 13);

        // Add OpenStreetMap tiles
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        var markers = [];
        var routes = [];

        // Function to add a marker to the map
        function addMarker(lat, lng) {
            var marker = L.marker([lat, lng]).addTo(map);
            markers.push(marker);
        }

        // Event listener for the 'Add Marker' button
        document.getElementById('addMarkerBtn').addEventListener('click', function() {
            // Hardcoded coordinates for the sake of simplicity
            addMarker(51.5, -0.09);
        });

        // Function to calculate and display a route between markers
        function calculateRoute() {
            if (markers.length < 2) {
                alert("At least two markers are needed to calculate a route");
                return;
            }
            
            var latlngs = markers.map(function(marker) {
                return marker.getLatLng();
            });

            var route = L.polyline(latlngs, {color: 'blue'}).addTo(map);
            routes.push(route);
        }

        // Event listener for the 'Calculate Route' button
        document.getElementById('calculateRouteBtn').addEventListener('click', calculateRoute);

        // Function to fetch and display location data (e.g., weather)
        function fetchLocationData(lat, lng) {
            fetch(`https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lng}&appid=YOUR_API_KEY`)
                .then(response => response.json())
                .then(data => {
                    console.log('Weather data:', data);
                    alert(`Weather at (${lat}, ${lng}): ${data.weather[0].description}`);
                })
                .catch(error => console.error('Error fetching weather data:', error));
        }

        // Intentional mistake: Missing event listener to fetch data for specific markers
        // This needs to be implemented by the interviewee
    </script>
</body>
</html>
```
